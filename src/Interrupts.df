#include "<df>/dragonfruit.h"
#include "<inc>/a3x.h"

table InterruptHandlers[64]

var SavedState 0
public SavedState

extern setvector { -- }

fn InterruptsInit { -- }
	setvector
end

asm "

setvector:
	la   t0, exception_limn2k
	mtcr evec, t0

	la   t0, firmware_call
	mtcr fwvec, t0

	ret

exception_limn2k:
	mov  t0, sp
	subi sp, sp, 12
	mov  long [sp + 8], t0
	mov  long [sp + 4], 0
	mov  long [sp], 0

	mfcr a3, ecause
	mfcr a2, epc
	mfcr a1, ers
	mfcr a0, ebadaddr
	jal  Exception

	j    Reset

;this global is fine because firmware calls will NEVER be nested
savedfwcallLR:
	.dl 0

firmware_call:
	la   t0, savedfwcallLR
	mov  long [t0], lr

	mfcr t0, epc
	subi t0, t0, 4
	mov  t0, long [t0]
	rshi t0, t0, 6
	la   t1, 0x3FFFFF
	and  t0, t0, t1

	la   t1, API
	mov  t0, long [t1 + t0 LSH 2]

	jalr lr, t0, 0

	la   t0, savedfwcallLR
	mov  lr, long [t0]
	rfe

"

table ExceptionNames
	"Unknown0"
	"Interrupt"
	"Syscall"
	"Firmware call"
	"Bus error"
	"Unknown5"
	"Breakpoint"
	"Invalid instruction"
	"Privilege violation"
	"Unaligned address"
	"Unknown10"
	"Unknown11"
	"Page fault"
	"Page fault write"
	"Unknown14"
	"Unknown15"
endtable
const ExceptionCount 16

const Breakpoint 6

const ExtInterrupt 1

const LSICClaimComplete 0xF8030010

fnptr IntHandler { -- }

fn Exception { state ecause epc ers badaddr -- }
	if (ecause@ ExtInterrupt ==)
		auto int

		LSICClaimComplete@ int!

		while (int@)
			auto h
			[int@]InterruptHandlers@ h!

			if (h@)
				h@ IntHandler
			end else
				int@ "Spurious interrupt: %x\n" Problem
			end

			int@ LSICClaimComplete!

			LSICClaimComplete@ int!
		end

		return
	end

	ConsoleUserOut

	ecause@ "ECAUSE: %x\n" Printf
	epc@ "EPC: %x\n" Printf
	ers@ "ERS: %x\n" Printf
	badaddr@ "BADADDR: %x\n" Printf

	if (ConsoleInMethod@ 0 ~=)
		if (ecause@ Breakpoint ==)
			epc@ "\[[7mA3X: breakpoint at 0x%x, entering monitor\[[0m\n" Printf
			state@ DebugMonitor
			return
		end else
			state@ SavedState!
			[ecause@]ExceptionNames@ "%s.\n" Problem
		end
	end else
		epc@ [ecause@]ExceptionNames@ "\n!!!FAULT!!! %s, resetting.\n" Printf

		LateReset
	end
end

fn InterruptRegister { handler num -- }
	handler@ [num@]InterruptHandlers!
end

fn InterruptUnregister { num -- }
	0 [num@]InterruptHandlers!
end

const Limn2500IntOffMask 0xFFFD

asm "

InterruptEnable:
.global InterruptEnable
	mfcr t0, rs
	ori  t0, t0, 2
	mtcr rs, t0
	ret

InterruptDisable:
.global InterruptDisable
	mfcr a0, rs
	andi t0, a0, Limn2500IntOffMask
	mtcr rs, t0
	ret

InterruptRestore:
.global InterruptRestore
	mtcr rs, a0
	ret

"